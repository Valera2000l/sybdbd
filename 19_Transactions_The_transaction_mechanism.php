<meta name="viewport" content="width=device-width, initial-scale=1">

   <link rel="stylesheet" href="css/topic.css">

  <link rel="stylesheet" href="css/registration.css">
 <link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
 <link rel="shortcut icon" href="image/icon.png" type="image/x-icon"> 

   <title>Транзакции. Механизм транзакций</title>


 	<header>
		<?php 
    include('nav.php');
    include('reg.php');
    include('cont.php');
    include('user.php');
    ?> 
	</header>
 	<main  class="m">
  <div  id="back" ><a href="topic.php" >     &lArr; Назад</a></div>

 <div class="page" id="page">
  <p class="p" ><b>РАЗДЕЛ 4. АРХИТЕКТУРА КЛИЕНТ-СЕРВЕР (INTERBASE, MYSQL,ORACLE)  </b>
  <p class="title">Тема 4.3. Транзакции. Механизм транзакций</p>

<p class="p"><b>Поддержание механизма транзакций</b> - показатель развитости <a href="glossary.php#sybd" class="gl" title="Узнать значение">СУБД</a>. Корректное поддержание транзакций одновременно является основой обеспечения целостности базы данных, а также составляет базис изолированности пользователей в многопользовательских СУБД.
<p class="definition"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="info" class="svg-inline--fa fa-info fa-w-6 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="currentColor" d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"></path></svg><b><u>Транзакция</u></b> представляет собой последовательность операторов языка <a href="glossary.php#SQL" class="gl" title="Узнать значение">SQL</a>, которая рассматривается как некоторое неделимое действие над базой данных, осмысленное с точки зрения пользователя.</p>
<p class="p"><b>Например</b>, если имеется структура данных следующего вида: «Персонал (номер, фамилия, адрес, телефон, должность, зарплата)», то простейшей транзакцией может быть модификация зарплаты определенного работника. 
<p class="p"><b>Пример транзакции: </b>Необходимо <u>перевести</u> с банковского счёта номер 5 на счёт номер 7 сумму в 10 денежных единиц. Этого можно достичь, к примеру, приведённой последовательностью действий:
<ul>
  <li><p class="q"><i>Начать транзакцию</i>
<p class="q">прочесть баланс на счету номер 5<br>
<p class="q">уменьшить баланс на 10 денежных единиц<br>
<p class="q">сохранить новый баланс счёта номер 5<br>
<p class="q">прочесть баланс на счету номер 7<br>
<p class="q">увеличить баланс на 10 денежных единиц<br>
<p class="q">сохранить новый баланс счёта номер 7<br>
<li><p class="q"><i>Окончить транзакцию</i>
</ul>
<p class="p">Эти действия представляют собой логическую единицу работы «перевод суммы между счетами», и таким образом, являются транзакцией. Если прервать данную транзакцию, к примеру, в середине, и не аннулировать все изменения, легко оставить владельца счёта номер 5 без 10 единиц, тогда как владелец счета номер 7 их не получит.

<p class="p"><b>Свойства транзакций</b>
<p class="p">Одним из наиболее распространённых наборов требований к транзакциям и транзакционным системам является набор <b>ACID</b> (Atomicity, Consistency, Isolation, Durability). Требования ACID были в основном сформулированы в конце 70-х годов Джимом Греем[1]. Вместе с тем существуют специализированные системы с ослабленными транзакционными свойствами.
<p class="p"><i>Понимание транзакции может быть охарактеризовано четырьмя классическими свойствами:</i>
<p class="p"><b>Atomicity — Атомарность</b>
<p class="p">Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся в исходное состояние.
<p class="p"><b>Consistency — Согласованность</b>
<p class="p">Одно из самых сложных и неоднозначных свойств из четвёрки ACID. В соответствии с этим требованием, система находится в согласованном состоянии до начала транзакции и должна остаться в согласованном состоянии после завершения транзакции. Не нужно путать требование согласованности с требованиями целостности (integrity). Последние правила являются более узкими и, во многом, специфичны для <u>реляционных СУБД</u>: есть требования целостности типов (domain integrity), целостности ссылок (referential integrity), целостности сущностей (entity integrity), которые не могут быть нарушены физически в силу особенностей реализации системы.
<p class="p">Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.
<p class="p">Наконец, ещё одно замечание касается того, что в <i>ходе</i> выполнения транзакции согласованность <i>не требуется</i>. В нашем примере списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.
<p class="p"><b>Isolation — Изолированность</b> 
<p class="p">Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Это свойство не соблюдается на уровне изолированности Repeatable Read и ниже.
<p class="p">Свойство изолированности означает, что конкурирующие за доступ к базе данных транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит так, как будто они выполняются параллельно; промежуточные результаты незавершенной транзакции не должны быть доступны другим транзакциям
<p class="p"><b>Durability — Надежность</b>
Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
<p class="p"><b><center>Уровни изоляции транзакций </center></b>
 <p class="p"> В идеале транзакции разных пользователей должны выполняться так, чтобы создавалась иллюзия, что пользователь текущей транзакции — единственный. Однако в реальности, по соображениям производительности и для выполнения некоторых специальных задач, СУБД предоставляют различные уровни изоляции транзакций.
<p class="p">Уровни описаны в порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными.
<ul>
<li><p class="q"><b> 0 — Чтение неподтверждённых данных (грязное чтение)</b> (Read Uncommitted, Dirty Read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения (lost changes), возможны неповторяемое чтение и фантомы.
<li><p class="q"><b> 1 — Чтение подтверждённых данных</b> (Read Committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.
<li><p class="q"><b> 2 — Повторяемое чтение</b> (Repeatable Read, Snapshot) — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
<li><p class="q"><b> 3 — Сериализуемый</b> — (Serializable) —сериализуемые транзакции. Результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.
<p class="p">Чем выше уровень изоляции, тем больше требуется ресурсов, чтобы его обеспечить. Соответственно, повышение изолированности может приводить к снижению скорости выполнения параллельных транзакций, что является «платой» за повышение надёжности.
<p class="p">В СУБД уровень изоляции транзакций можно выбрать как для всех транзакций сразу, так и для одной конкретной транзакции. По умолчанию в большинстве баз данных используется уровень 1 (Read Committed). Уровень 0 используется в основном для отслеживания изменений длительных транзакций или для чтения редко изменяемых данных. Уровни 2 и 3 используются при повышенных требованиях к изолированности транзакций.
<p class="p"><b>Транзакции и целостность баз данных.</b>
<p class="p">Возможны два варианта завершения работы транзакции. Если все операторы выполнены успешно и в процессе выполнения транзакции не произошло никаких сбоев программного или аппаратного обеспечения, транзакция фиксируется. <b>Фиксация транзакции</b> (commit)- это действие, обеспечивающее запись на диск изменений в базе данных, которые были сделаны в ходе выполнения транзакции. До тех пор, пока транзакция не зафиксирована, возможно произвести отмену всех изменений и восстановить базу данных в исходное, на момент начала транзакции, состояние. Фиксация означает, что все результаты выполнения транзакции становятся постоянными и доступными другим пользователям системы. Надо отметить, что до момента фиксации транзакции пользователи имеют дело с данными, в том виде, в котором они находились на момент начала выполнения текущей транзакции.
<p class="p">Если же в процессе работы случилось нечто, что делает выполнение транзакции невозможным, база данных возвращается в исходное состояние. <b>Откат транзакции</b> (roll back)- это действие, обеспечивающее аннулирование всех изменений данных, которые были сделаны операторами SQL в теле текущей незавершенной транзакции.
<p class="p">Если оказывается, что зафиксированная транзакция является ошибочной, то требуется выполнить другую транзакцию, отменяющую действия, выполненные первой транзакцией. Такая транзакция называется <b>компенсирующей</b>.
<p class="p">В стандарте ANSI/ISO SQL определены модель транзакций и функции операторов COMMIT и ROLLBACK. Стандарт определяет, что транзакция начинается с первого SQL-оператора, инициируемого пользователем или содержащемся в программе. Все последующие операторы составляют тело транзакции.  Транзакция завершается одним из четырех возможных вариантов (рис.1):
<p class="q"><b>a)</b>  оператор COMMIT означает успешное завершение транзакции; его использование делает постоянными изменения, внесенные в базу данных в рамках текущей транзакции;
<p class="q"><b>b)</b>  оператор ROLLBACK прерывает транзакцию, отменяя все изменения, сделанные в рамках текущей транзакции; новая транзакция начинается непосредственно после оператора ROLLBACK;
<p class="q"><b>c)</b>  успешное завершение программы, в которой была инициирована текущая транзакция, означает успешное завершение транзакции (аналогично работе оператора COMMIT);
<p class="q"><b>d)</b>  ошибочное завершение программы прерывает выполнение транзакции (аналогично работе оператора ROLLBACK).
<p class="p"><center><img src="lectures/19.png" width="650" height="290" class="top_img min_i"  /></center>
<p class="p"><center>Рис.1.</center>
<p class="p">Различаются два вида ограничений целостности: <b>немедленно проверяемые</b> и откладываемые. К немедленно проверяемым относятся ограничения целостности, проверку которых бессмысленно или невозможно откладывать (например, ограничение на возрастные рамки - более 150 лет). Эти ограничения целостности соответствуют уровню отдельных операторов языка СУБД и при их нарушении производится не откат транзакции, а лишь отвергается определенный оператор. <b>Откладываемые ограничения</b> - это ограничения на базу данных, а не на какие-либо отдельные операции. По умолчанию такие ограничения проверяются в конце транзакции, и их нарушение  вызывает автоматическую замену оператора COMMIT на оператор ROLLBACK. Однако в некоторых системах поддерживается специальный оператор насильственной поддержки ограничений целостности внутри транзакций.
<p class="p">Возможности отката и фиксации транзакция обеспечивается благодаря наличию в СУБД функции ведения журнала транзакций.
<p class="p"><b>Параллельное выполнение транзакций.</b>
<p class="p">В том случае, если с базой данных одновременно работают несколько пользователей, СУБД должна не только корректно выполнить индивидуальные транзакции и восстанавливать согласованное состояние базы данных, но и  обеспечить корректную параллельную работу всех пользователей над одними и теми же данными. 
<p class="p">Рассмотрим фрагмент полной схемы построения СУБД, включающих четыре высокоуровневых модуля, отвечающих за выполнение и обработку транзакций, управление параллельностью и выполнение восстановления системы (рис.2).
<p class="p"><center><img src="lectures/20.png" width="466" height="275" class="top_img min_i"  /></center>
<p class="p"><center>Рис.2 Подсистема обработка транзакций типичной СУБД.</center>
<p class="p">Менеджер транзакций осуществляет координацию работы транзакций, выполняемых прикладными программами. Он взаимодействует с планировщиком (менеджер блокировок), отвечающим за реализацию выбранной стратегии управления параллельностью; второе название применимо в том случае, если выбран протокол управления на основе системы блокировок. Цель работы планировщика – достижение максимально возможного уровня параллельности, при условии исключения влияния параллельно выполняющихся транзакций друг на друга, поскольку это может послужить источником нарушения согласованности базы данных. Если в процессе выполнения транзакции происходит откат, то база данных может находиться в несогласованном состоянии. Задачей менеджера восстановления является предоставление гарантий того, что в подобном случае база данных будет автоматически восстановлена в то состояние, в котором она находилась на момент начала выполнения транзакции. Менеджер буферов отвечает за передачу данных основной памяти компьютера и вторичной дисковой памяти.
<p class="p">Исходя из теории, что каждый пользователь и каждая транзакция должны обладать свойством изолированности, они должны выполняться так, как если бы только один пользователь работал с базой данных. Средства СУБД позволяют изолировать пользователей друг от друга, однако в этом случае возникают проблемы с замедлением работы. Рассмотрим проблемы, возникающие при параллельной обработке транзакций; их принято подразделять на 4 класса:
<p class="q">1.  <b>Пропавшие (незафиксированные) изменения</b>. Эта ситуация может возникнуть, возникнуть в том случае, когда две транзакции одновременно выполняют изменения в одной и той же записи. Например, два оператора работают на приеме заказов. Первый оператор принял заказ на 30 мониторов, в то время как на складе хранилось 40 мониторов. Получив подтверждение на заказ от покупателя, оператором был выставлен счет на это количество товара и оформлена покупка (обновление записи о количестве товара на складе – 10). В это же время второй оператор принимает заказ на 20 мониторов, принимая во внимание начальное их количество на складе – 40 штук, и также оформляет покупку (также выполняет команду обновить для количества товара на складе- 10). Таким образом, было продано 50 мониторов, в то время как фактически их количество – 40, и на складе существует положительный остаток в 10 ед. База данных находится в несогласованном состоянии, по той причине, что изменения, сделанные операторами были проигнорированы.
<p class="q">2.<b>  Проблемы промежуточных данных</b>. Рассмотрим эту же ситуацию. Первый оператор ведет переговоры с заказчиком и указывает в заказе 30 мониторов, однако перед окончательным выставлением счета он намеревается уточнить некоторые характеристики товара. На диске уже зафиксированы изменения в остатках товара на складе, произведенные первым оператором (остаток – 10 ед. товара). В это время второй оператор работает над формированием собственного заказа на 20 ед. товара, и последние данные по остаткам товара не позволяют ему этот заказ сформировать; приложение второго оператора оканчивает работу. После уточнения характеристик покупаемого товара, первый заказчик отказывается от покупки 30 мониторов, и приложение первого оператора выполняет откат транзакции, возвращая нас к исходному значению товара на складе в 40 ед. Такая ситуация сложилась по той причине, что в процессе выполнения второй транзакции был открыт доступ к данным, которые сформировала первая транзакция. 
<p class="q">3. <b> Проблема несогласованных данных</b>. Представим себе, что, начиная работать почти одновременно, оба оператора получают информацию о наличие на складе 40 ед. товара. Первый оператор завершает переговоры со своим клиентом и продает ему 30 ед. товара; транзакция завершается оператором COMMIT. Состояние базы данных расценивается как непротиворечивое. Пока второй оператор согласовывал условия заказа, он получает новое состояние склада, которое уже успело измениться. База данных находится в непротиворечивом состоянии, однако второй оператор считает, что нарушена целостность выполнения его транзакции. Это состояние возникло по той причине, что транзакция первого оператора смогла изменить кортеж с данными, который уже был прочитан второй транзакцией.
<p class="q">4. <b> Проблемы строк</b> - признаков. Предположим, что необходимо подготовить два отчета за анализируемый период: стандартный и расширенный. В то время когда приложение печати начинает формировать первый отчет, оператор принимает еще один заказ, укладывающийся в указанный период. Это приводит к тому, что к моменту формирования расширенного отчета в базе данных появились новые данные. Полученные отчеты в рамках одной транзакции содержат противоречивые данные. Это вызвано тем, что, хотя базы данных находилась в согласованном состоянии, приложения печати работали некорректно.

<p class="p"><b>Сериализация транзакций</b>
<p class="p">Во избежание подобных ситуаций требуется разработать определенную процедуру, обеспечивающая согласованность выполнения параллельных транзакций, т.е. изолированность транзакций. Эта процедура в СУБД носит название сериализации транзакций. Для поддержки параллельной работы транзакции строится специальный план. План выполнения набора транзакций называется сериальным, если результат совместного выполнения транзакций эквивалентен результату некоторого последовательного выполнения этих же транзакций. 
<p class="definition"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="info" class="svg-inline--fa fa-info fa-w-6 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="currentColor" d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"></path></svg><b><u>Сериализация транзакций</u></b> - это механизм выполнения транзакций  по некоторому сериальному плану. Обеспечение такого механизма является основной функцией компонента СУБД, ответственного за управление транзакциями.</p>

<p class="p">Данная дисциплина опирается на следующие правила:
<p class="p"><b>1.</b>  В процессе выполнения транзакции программа «видит» только согласованные состояния базы данных; пользователь никогда не может получить доступ к незафиксированным изменениям в данных, достигнутым в результате действия другой программы;
<p class="p"><b>2. </b> Если две транзакции А и В выполняются параллельно, то СУБД полагает, что результат будет такой же, как если бы: - транзакция А выполнялась бы первой, а за ней - выполнялась другая транзакция В, т.е. последовательно. 



<div id="otp_wgt_cc7qbm2gc2sey"></div>
<script type="text/javascript">
    var otp_wjs_dt = (new Date).getTime();
    (function (w, d, n, s, rp) {
        w[n] = w[n] || [];
        rp = {};
        w[n].push(function () {
            otp_render_widget(d.getElementById("otp_wgt_cc7qbm2gc2sey"), 'onlinetestpad.com', 'cc7qbm2gc2sey', rp);
        }); 
        s = d.createElement("script");
        s.type = "text/javascript";
        s.src = "//onlinetestpad.com/js/widget.js?" + otp_wjs_dt;
        s.async = true;
        d.getElementsByTagName("head")[0].appendChild(s);
    })(this, this.document, "otp_widget_callbacks");
</script>



<div class="navbt">
	<div class=" btn red d">
		<a  href="18_Working_with_BLOB_and_user-defined_functions.php" >Предыдущая 
			<div class="btn__blobs">
		      <div></div>
		      <div></div>
		      <div></div>
    		</div>
  		</a>
  	</div>
	<div class=" btn red d">
		<a href="20_Steps_for_creating_an_application.php">Следующая
			<div class="btn__blobs">
		      <div></div>
		      <div></div>
		      <div></div>
   			</div>
   		</a>
   	</div>
 </div>
</p>
</div>
</main>
 <script src="https://snipp.ru/cdn/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://snipp.ru/cdn/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <script src="https://snipp.ru/cdn/fancybox/2.1.7/source/jquery.fancybox.pack.js"></script>
    <script src="js/registration.js"></script>
    <script src="js/user.js"></script>  
    <script src="js/topic.js"></script>
    