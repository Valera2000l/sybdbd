<meta name="viewport" content="width=device-width, initial-scale=1">

   <link rel="stylesheet" href="css/topic.css">

  <link rel="stylesheet" href="css/registration.css">
 <link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
 <link rel="shortcut icon" href="image/icon.png" type="image/x-icon"> 

   <title>Структуры внешней памяти, методы организации индексов</title>


 	<header>
		<?php 
    include('nav.php');
    include('reg.php');
    include('cont.php');
    include('user.php');
    ?> 
	</header>
 	<main  class="m">
  <div  id="back" ><a href="topic.php" >     &lArr; Назад</a></div>

 <div class="page" id="page">
  <p class="p" ><b>РАЗДЕЛ 2 ВНУТРЕННЯЯ ОРГАНИЗАЦИЯ РЕЛЯЦИОННЫХ СУБД</b>
  <p class="title">Тема 2.1 Структуры внешней памяти, методы организации индексов</p>

<p class="p"><b>Особенности реляционных СУБД</b>
<p class="p">Реляционные СУБД обладают рядом особенностей, влияющих на организацию внешней памяти. К наиболее важным особенностям можно отнести следующие: 
<ul>
<li><p class="q"><u> Наличие двух уровней системы управления данными</u>: <b>уровня непосредственного управления данными во внешней памяти</b> (а также обычно управления буферами оперативной памяти, управления транзакциями и журнализацией изменений БД) и <b>языкового уровня</b> (например, уровня, реализующего язык SQL). При такой организации <u>подсистема нижнего уровня</u> должна поддерживать во внешней памяти <u>набор базовых структур</u>, конкретная интерпретация которых входит в число функций подсистемы верхнего уровня. 
<li><p class="q">Поддержание <u>таблиц-каталогов для хранения метаинформации</u>. Информация, связанная с именованием <u>объектов базы данных</u> и их конкретными свойствами (например, структура ключа индекса), поддерживается подсистемой языкового уровня. С точки зрения структур внешней памяти <i>отношение-каталог ничем не </i> от обычного отношения базы данных. 
<li><p class="q">Регулярность структур данных. Поскольку основным объектом реляционной модели данных является плоская таблица, главный набор объектов внешней памяти может иметь очень <u>простую регулярную структуру</u> т.е. постоянно повторяющуюся. 
<li><p class="q"> При этом необходимо обеспечить возможность <u>эффективного выполнения операторов языкового уровня</u> как над одним отношением (простые селекция и проекция), так и над несколькими отношениями (наиболее распространено и трудоемко соединение нескольких отношений). Для этого во внешней памяти должны поддерживаться дополнительные "управляющие" структуры -<b><i> индексы</i></b>. 
<li><p class="q"> Наконец, для выполнения требования <b><i>надежного хранения</i></b> баз данных необходимо поддерживать <u>избыточность хранения данных</u>, что обычно реализуется в виде <u> журнала изменений базы данных</u>. 
</ul>
<p class="p"><b><center>Набор базовых структур</center></b>
<p class="p">Соответственно возникают следующие разновидности объектов во внешней памяти базы данных: 
 <ul>
<li><p class="q"><b><i> строки отношений</i></b> - основная часть базы данных, большей частью непосредственно видимая пользователям; 
<li><p class="q"><b><i> управляющие структуры</i></b> - индексы, создаваемые по инициативе пользователя (администратора) или верхнего уровня системы из соображений повышения эффективности выполнения запросов и обычно автоматически поддерживаемые нижним уровнем системы; 
<li><p class="q"><b><i> журнальная информация</i></b>, поддерживаемая для удовлетворения потребности в надежном хранении данных; 
<li><p class="q"><b><i> служебная информация</i></b>, поддерживаемая для удовлетворения внутренних потребностей нижнего уровня системы (например, информация о свободной памяти). 
</ul>
<p class="p"><b><center>Хранение отношений</center></b>
<p class="p">Существуют <b>два принципиальных подхода к физическому хранению отношений</b>:
  <ul>
<li><p class="q">Наиболее распространенным является <b><i>покортежное хранение отношений</i></b> (кортеж является единицей физического хранения). Естественно, это обеспечивает быстрый доступ к целому кортежу, но при этом во внешней памяти <u>дублируются общие значения разных кортежей одного отношения</u> и, вообще говоря, могут потребоваться лишние обмены с внешней памятью, если нужна часть кортежа. 
<ul>
<li><p class="q">Альтернативным (менее распространенным) подходом является <b><i>хранение отношения по столбцам</i></b>, т.е.<u> единицей хранения является столбец отношения с исключенными дубликатами</u>. Естественно, что при такой организации суммарно в среднем тратится <u>меньше внешней памяти</u>, поскольку дубликаты значений не хранятся; за один обмен с внешней памятью в общем случае считывается больше полезной информации. Дополнительным преимуществом является возможность использования значений столбца отношения для оптимизации выполнения операций соединения. Но при этом требуются <u>существенные дополнительные действия для сборки</u> целого кортежа (или его части). 
</ul>
<p class="p">Поскольку гораздо более распространено хранение по строкам, мы рассмотрим немного более подробно этот способ хранения отношений. Типовой структурой страницы данных является следующая: 
  <p class="p"><center><img src="lectures/14.png" width="221" height="270" class="top_img" /></center>
<p class="p">К основным характеристикам этой организации можно отнести следующие: 
<ul>
<li><p class="q">  Каждый кортеж обладает уникальным идентификатором, не изменяемым во все время существования кортежа. Структура идентификатора следует из приведенного выше рисунка. 
<li><p class="q"> Обычно <u><b>каждый кортеж хранится целиком в одной странице</b></u>. Из этого следует, что максимальная длина кортежа любого отношения ограничена размерами страницы. Возникает вопрос: как быть с "длинными" данными, которые в принципе не помещаются в одной странице? Применяются несколько методов. Наиболее простым решением является хранение таких данных <u>в отдельных (вне базы данных) файлах с заменой "длинного" данного в кортеже на имя соответствующего файла</u>. Это решение сильно ограничивают возможность работы с длинными данными (как, например, удалить несколько байтов из середины 2-мегабайтной строки?). В настоящее время все чаще используется метод, когда "длинные" данные организуются в виде B-деревьев (двоичных деревьев) последовательностей байтов. 
<li><p class="q"><u><b> Как правило, в одной странице данных хранятся кортежи только одного отношения</b></u>. Существуют, однако, варианты с возможностью хранения в одной странице кортежей нескольких отношений. Это вызывает некоторые дополнительные расходы по части служебной информации (при каждом кортеже нужно хранить информацию о соответствующем отношении), но зато иногда позволяет резко сократить число обменов с внешней памятью при выполнении соединений. 
<li><p class="q"> Изменение схемы хранимого отношения с добавлением нового столбца не вызывает потребности в физической реорганизации отношения. Достаточно лишь изменить информацию в описателе отношения и расширять кортежи только при занесении информации в новый столбец. 
<li><p class="q"> Поскольку отношения могут содержать неопределенные значения, необходима соответствующая поддержка на уровне хранения. 
<li><p class="q"> Проблема распределения памяти в страницах данных связана с проблемами синхронизации транзакций и журнализации и не всегда тривиальна. Например, если в ходе выполнения транзакции некоторая страница данных опустошается, то ее нельзя перевести в статус свободных страниц до конца транзакции, поскольку при откате транзакции удаленные при прямом выполнении транзакции и восстановленные при ее откате кортежи должны получить те же самые идентификаторы и значения. 
<li><p class="q"> Распространенным способом повышения эффективности СУБД является <b><i>кластеризация</i></b> отношения (т.е. хранение одновременно вызываемых кортежей разных отношений в одной области жесткого диска) по значениям одного или нескольких столбцов. Полезным для оптимизации соединений является совместная кластеризация нескольких отношений. 
</ul>
<p class="p"><u>Что же касается хранения отношения по столбцам</u>, то основная идея состоит в совместном хранении всех значений одного (или нескольких) столбцов. Для каждого кортежа отношения хранится кортеж той же степени, состоящий из ссылок на места расположения соответствующих значений столбцов. В дальнейших лекциях мы будем рассматривать особенности организации распределенных реляционных СУБД. Одним из приемов является так называемое вертикальное разделение отношений, когда в разных узлах сети хранятся разные проекции данного отношения. Хранение отношения по столбцам в некотором смысле является предельным случаем вертикального разделения отношений. 
 
<p class="p"><b><center>Индексы</center></b>
<p class="p">Как бы не были организованы индексы в конкретной СУБД, <u>их основное назначение состоит в обеспечении эффективного прямого доступа к кортежу отношения по ключу</u>. Индекс определяется для одного отношения, и ключом является значение атрибута (возможно, составного). Если ключом индекса является <u>возможный ключ отношения, то индекс должен обладать свойством уникальности</u>, т.е. не содержать дубликатов ключа. На практике ситуация выглядит обычно так: <u>при объявлении первичного ключа отношения автоматически заводится уникальный индекс, а единственным способом объявления возможного ключа, отличного от первичного, является явное создание уникального индекса</u>. Это связано с тем, что для проверки сохранения свойства уникальности возможного ключа, так или иначе, требуется индексная поддержка. 
<p class="p">Поскольку при выполнении многих операций языкового уровня требуется сортировка отношений в соответствии со значениями некоторых атрибутов, <u>полезным свойством индекса</u> является обеспечение последовательного просмотра кортежей отношения в диапазоне значений индекса<u> в порядке возрастания или убывания значений</u>. 
<p class="p">Наконец, одним из способов оптимизации выполнения эквисоединения отношений (наиболее распространенная из числа дорогостоящих операций) является <u>организация так называемых мультииндексов для нескольких отношений, обладающих общими атрибутами</u>. Любой из этих атрибутов (или их набор) может выступать в качестве ключа мультииндекса.<u> Значению ключа сопоставляется набор кортежей всех связанных мультииндексом отношений, значения выделенных атрибутов которых совпадают со значением ключа</u>. 
<p class="p">Общей идеей любой организации индекса, поддерживающего прямой доступ по ключу и последовательный просмотр в порядке возрастания или убывания значений ключа является <u>хранение упорядоченного списка значений ключа</u> с привязкой к каждому значению ключа <u>списка идентификаторов кортежей</u>. Одна организация индекса отличается от другой главным образом в способе поиска ключа с заданным значением. 
<p class="p"><b><center>B-деревья</center></b>
<p class="p">Видимо, наиболее популярным подходом к организации индексов в базах данных является использование техники B-деревьев. С точки зрения внешнего логического представления <b>B-дерево</b> - это сбалансированное сильно ветвистое дерево во внешней памяти. <u>Сбалансированность означает, что длина пути от корня дерева к любому его листу одна и та же</u>. Ветвистость дерева - это свойство каждого узла дерева ссылаться но большое число узлов-потомков. <u>С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц внешней памяти, т.е. каждому узлу дерева соответствует блок внешней памяти (страница)</u>. Внутренние и листовые страницы обычно имеют разную структуру. 
<p class="p"><b>Поиск в B-дереве</b> - это прохождение от корня к листу в соответствии с заданным значением ключа. Заметим, что поскольку деревья сильно ветвистые и сбалансированные, то для выполнения поиска по любому значению ключа потребуется одно и то же (и обычно небольшое) число обменов с внешней памятью. Более точно, в сбалансированном дереве, где длины всех путей от корня к листу одни и те же, если во внутренней странице помещается n ключей, то при хранении m записей требуется дерево глубиной logn(m), где logn вычисляет логарифм по основанию n. Если n достаточно велико (обычный случай), то глубина дерева невелика, и производится быстрый поиск. 
<p class="p">Основной "изюминкой" B-деревьев является автоматическое поддержание свойства сбалансированности. 
<p class="p"><b><center>Хэширование</center></b>
<p class="p">Альтернативным деревьям и все более популярным подходом к организации индексов является использование техники <b>хэширования</b>. Это очень обширная тема, которая заслуживает отдельного рассмотрения. Мы ограничимся лишь несколькими замечаниями. Общей идеей методов хэширования является применение к значению ключа некоторой функции гомоморфного отображения в адрес - <b>свертки (хэш-функции)</b>, вырабатывающей значение меньшего размера. Свертка значения ключа затем используется для доступа к записи. 
<p class="p">В самом простом, классическом случае, свертка ключа используется как адрес в таблице, содержащей ключи и записи. Основным требованием к хэш-функции является равномерное распределение значение свертки. При возникновении <b>коллизий</b> (одна и та же свертка для нескольких значений ключа) образуются цепочки переполнения. Главным ограничением этого метода является фиксированный размер таблицы. Если таблица заполнена слишком сильно или переполнена, но возникнет слишком много цепочек переполнения, и главное преимущество хэширования - доступ к записи почти всегда за одно обращение к таблице - будет утрачено. Расширение таблицы требует ее полной переделки на основе новой хэш-функции (со значением свертки большего размера). 
<p class="p">В случае баз данных такие действия являются абсолютно неприемлемыми. Поэтому обычно вводят промежуточные таблицы-справочники, содержащие значения ключей и адреса записей, а сами записи хранятся отдельно. Тогда при переполнении справочника требуется только его переделка, что вызывает меньше накладных расходов. 
<p class="p">В целом методы B-деревьев и хэширования все более сближаются. 
<p class="p"><b><center>Журнальная информация</center></b>
<p class="p">Структура журнала в определенном смысле является сугубо частным делом конкретной реализации. Мы отметим только самые общие свойства. 
<p class="p"><p class="definition"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="info" class="svg-inline--fa fa-info fa-w-6 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path fill="currentColor" d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"></path></svg><b><u>Журнал</u></b> обычно представляет собой последовательный файл с записями переменного размера, которые можно просматривать в прямом или обратном порядке.</p>
<p class="p"> Обмены производятся стандартными порциями (страницами) с использованием буфера оперативной памяти. В грамотно организованных системах структура (и тем более, смысл) журнальных записей известна только компонентам СУБД, ответственным за журнализацию и восстановление. Поскольку содержимое журнала является критичным при восстановлении базы данных после сбоев, к ведению файла журнала предъявляются особые требования по части надежности. В частности, обычно стремятся поддерживать <u>две идентичные копии</u> журнала на разных устройствах внешней памяти. 
 
<p class="p"><b><center>Служебная информация</center></b>
<p class="p">Для корректной работы подсистемы управления данными во внешней памяти необходимо поддерживать информация, которая используется только этой подсистемой и не видна подсистеме языкового уровня. Набор структур служебной информации зависит от общей организации системы, но обычно требуется поддержание следующих служебных данных: 
<ul>
<li><p class="q"> <b><i>  Внутренние каталоги</i></b>, описывающие физические свойства объектов базы данных, например, число атрибутов отношения, их размер и, возможно, типы данных; описание индексов, определенных для данного отношения и т.д. 
<li><p class="q"> <b><i>  Описатели свободной и занятой памяти в страницах отношения</i></b>. Такая информация требуется для нахождения свободного места при занесении кортежа. Отдельно приходится решать задачу поиска свободного места в случаях некластеризованных и кластеризованных отношений (в последнем случае приходится дополнительно использовать кластеризованный индекс). Как мы уже отмечали, нетривиальной является проблема освобождения страницы в условиях мультидоступа. 
<li><p class="q"> <b><i> Связывание страниц одного отношения</i></b>. Если в одном файле внешней памяти могут располагаться страницы нескольких отношений (обычно к этому стремятся), то нужно каким-то образом связать страницы одного отношения. Тривиальный способ использования прямых ссылок между страницами часто приводит к затруднениям при синхронизации транзакций (например, особенно трудно освобождать и заводить новые страницы отношения). Поэтому стараются использовать косвенное связывание (с помощью списков связного распределения памяти) страниц с использованием служебных индексов. 







<div class="navbt">
	<div class=" btn red d">
		<a  href="6_Designing_relational_databases_using_normalization.php" >Предыдущая 
			<div class="btn__blobs">
		      <div></div>
		      <div></div>
		      <div></div>
    		</div>
  		</a>
  	</div>
	<div class=" btn red d">
		<a href="8_Transaction_management.php">Следующая
			<div class="btn__blobs">
		      <div></div>
		      <div></div>
		      <div></div>
   			</div>
   		</a>
   	</div>
 </div>
</p>
</div>
</main>
 <script src="https://snipp.ru/cdn/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://snipp.ru/cdn/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <script src="https://snipp.ru/cdn/fancybox/2.1.7/source/jquery.fancybox.pack.js"></script>
    <script src="js/registration.js"></script>
    <script src="js/user.js"></script>  
    <script src="js/topic.js"></script>
    